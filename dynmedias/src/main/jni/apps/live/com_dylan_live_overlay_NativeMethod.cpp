/* DO NOT EDIT THIS FILE - it is machine generated */
#include <android/log.h>
#include <jni.h>
#include <stdio.h>
#include <memory>
#include <map>
#include <mutex>
#include "xchar.h"
#include "WriteLog.h"
#include <mutex>
#include "libyuv.h"

#include <opencv2/imgproc/imgproc.hpp>  // Gaussian Blur
#include <opencv2/core/core.hpp>        // Basic OpenCV structures (cv::Mat, Scalar)
#include <opencv2/highgui/highgui.hpp>  // OpenCV window I/O

#define OverlayMode_YUV     0
#define OverlayMode_RGB     1
#define OverlayFlag_Mono    0x02
#define OverlayFlag_Opacity 0x04

#define min(x, y)	((x < y) ? x : y)
#define MAKE_FOURCC(a, b, c, d) (((uint32_t)d) | (((uint32_t)c) << 8) | (((uint32_t)b) << 16) | ( ((uint32_t)a) << 24))
class COverlay {
protected:
    struct CLogo {
        CLogo(): key(nullptr), y(nullptr) {}
        ~CLogo() { delete[] key; delete[] y; }
        bool disabled;
        int capcity;
        int width;
        int height;
        int size;
        uint8_t* key;
        uint8_t* y;
        uint8_t* u;
        uint8_t* v;
        int left;
        int top;
        int flags;
    };
private:
    int m_overMode;
    int m_mainFourCC;

    std::mutex m_mutex;
    std::map<int, std::unique_ptr<CLogo>> m_logos;
    std::map<int, uint8_t*> m_auxes;
public:
	COverlay(int mode, int fourcc)
            : m_overMode(mode)
            , m_mainFourCC(fourcc)

            , m_logos()
            , m_auxes() {
	}
	~COverlay() {
	}
    void setLogo(int index, uint8_t* logo, int width, int height, int x, int y, int flags) {
        std::lock_guard<std::mutex> lock(m_mutex);
        if (logo == nullptr) {
            auto found = m_logos.find(index);
            if (found != m_logos.end()) m_logos.erase(found);
        } else {
            auto found = m_logos.find(index);
            bool reuse = false;
            CLogo* item = nullptr;
            if (found != m_logos.end() && found->second.get()->capcity >= width * height) {
                reuse = true;
                item = found->second.get();
            }
            else {
                item = new CLogo;
                item->capcity = width * height;
            }
            item->disabled = false;
            item->width = width;
            item->height = height;
            item->left = x >= 0 ? x : 0;
            item->top = y >= 0 ? y : 0;
            item->size = width * height;
            item->y = new uint8_t[item->size * 3 / 2];
            item->v = item->y + item->size;
            item->u = item->v + (item->size >> 2);
            item->flags = flags;
            libyuv::ARGBToI420(logo, width << 2, item->y, width, item->v, width >> 1, item->u, width >> 1, width, height);
            if (!(flags & OverlayFlag_Opacity)) {
                item->key = new uint8_t[item->size * 5 / 4];
                uint8_t *key = item->key;
                uint8_t *src = logo;
                for (int row = 0; row < height; row++) {
                    for (int col = 0; col < width; col++) {
                        if (*src > 127) *key = 1;
                        else *key = 0;
                        src += 4;
                        key += 1;
                    }
                }
                uint8_t* keyuv = item->key + item->size;
                for (int row = 0; row < height; row += 2) {
                    src = logo + ((row * width) << 2);
                    for (int col = 0; col < width; col += 2) {
                        if (*src > 127) *keyuv = 1;
                        else *keyuv = 0;
                        *keyuv = *src;
                        src += 8;
                        keyuv += 1;
                    }
                }
            }
            if (!reuse) {
                m_logos.insert(std::make_pair(index, std::unique_ptr<CLogo>(item)));
            }
        }
    }
    void setAux(int fourcc, uint8_t* aux) {
        std::lock_guard<std::mutex> lock(m_mutex);
        if (aux == nullptr || fourcc == 0) {
            auto found = m_auxes.find(fourcc);
            if (found != m_auxes.end()) m_auxes.erase(found);
        } else {
            m_auxes[fourcc] = aux;
        }
    }
    void overlayI420(uint8_t* mainY, uint8_t* mainU, uint8_t* mainV, int width, int height) {
        for (auto it = m_logos.begin(); it != m_logos.end(); it++) {
            CLogo* logo = it->second.get();
            int row = min(height - logo->top, logo->height);
            int pitch = min(width - logo->width, logo->width);
            uint8_t* srcY = logo->y;
            uint8_t* desY = mainY + width * logo->top + logo->left;
            if (!(logo->flags & OverlayFlag_Opacity)) {
                uint8_t* keyY = logo->key;
                for (int i = 0; i < row; i++) {
                    for (int j = 0; j < pitch; j++) {
                        if (keyY[j]) desY[j] = srcY[j];
//                        desY[j] = ((int)srcY[j] * keyY[j] + (int)desY[j] * (255 - keyY[j])) >> 8;
                    }
                    desY += width;
                    srcY += logo->width;
                    keyY += logo->width;
                }
            } else {
                for (int i = 0; i < row; i++) {
                    memcpy(desY, srcY, pitch);
                    desY += width;
                    srcY += logo->width;
                }
            }
            if (!(logo->flags & OverlayFlag_Mono)) {
                unsigned char *srcV = logo->v;
                unsigned char *desV = mainV + (width >> 1) * (logo->top >> 1) + (logo->left >> 1);
                unsigned char *srcU = logo->u;
                unsigned char *desU = mainU + (width >> 1) * (logo->top >> 1) + (logo->left >> 1);
                if (!(logo->flags & OverlayFlag_Opacity)) {
                    unsigned char *keyV = logo->key + logo->size;
                    for (int i = 0; i < row >> 1; i++) {
                        for (int j = 0; j < pitch >> 1; j++) {
//                            desU[j] = ((int)srcU[j] * keyV[j] + (int)desU[j] * (255 - keyV[j])) >> 8;
//                            desV[j] = ((int)srcV[j] * keyV[j] + (int)desV[j] * (255 - keyV[j])) >> 8;
                            if (keyV[j]) {
                                desU[j] = srcU[j];
                                desV[j] = srcV[j];
                            }
                        }
                        desU += (width >> 1);
                        srcU += (logo->width >> 1);
                        desV += (width >> 1);
                        srcV += (logo->width >> 1);
                        keyV += (logo->width >> 1);
                    }
                } else {
                    for (int i = 0; i < row >> 1; i++) {
                        for (int j = 0; j < pitch >> 1; j++) {
                            desU[j] = srcU[j];
                            desV[j] = srcV[j];
                        }
                        desU += (width >> 1);
                        srcU += (logo->width >> 1);
                        desV += (width >> 1);
                        srcV += (logo->width >> 1);
                    }
                }
            }
        }
    }
    void overlayNV12(uint8_t* mainY, uint8_t* mainUV, int width, int height, bool forNV21) {
        for (auto it = m_logos.begin(); it != m_logos.end(); it++) {
            CLogo* logo = it->second.get();
            int row = min(height - logo->top, logo->height);
            int pitch = min(width - logo->width, logo->width);
            uint8_t* srcY = logo->y;
            uint8_t* desY = mainY + width * logo->top + logo->left;
            if (!(logo->flags & OverlayFlag_Opacity)) {
                uint8_t *keyY = logo->key;
                for (int i = 0; i < row; i++) {
                    for (int j = 0; j < pitch; j++) {
                        if (keyY[j]) desY[j] = srcY[j];
                    }
                    desY += width;
                    srcY += logo->width;
                    keyY += logo->width;
                }
            } else {
                for (int i = 0; i < row; i++) {
                    memcpy(desY, srcY, pitch);
                    desY += width;
                    srcY += logo->width;
                }
            }
            if (!(logo->flags & OverlayFlag_Mono)) {
                unsigned char *srcV = logo->v;
                unsigned char *srcU = logo->u;
                unsigned char *desU = mainUV + width * (logo->top >> 1) + logo->left - 1;
                unsigned char *desV = mainUV + width * (logo->top >> 1) + logo->left - 1;
                if (forNV21) desU++;
                else desV++;
                if (!(logo->flags & OverlayFlag_Opacity)) {
                    unsigned char *keyV = logo->key + logo->size;
                    for (int i = 0; i < row >> 1; i++) {
                        for (int j = 0, k = 0; j < pitch >> 1; j++, k += 2) {
                            if (keyV[j]) {
                                desU[k] = srcU[j];
                                desV[k] = srcV[j];
                            }
                        }
                        desU += width;
                        srcU += (logo->width >> 1);
                        desV += width;
                        srcV += (logo->width >> 1);
                        keyV += (logo->width >> 1);
                    }
                } else {
                    for (int i = 0; i < row >> 1; i++) {
                        for (int j = 0, k = 0; j < pitch >> 1; j++, k += 2) {
                            desU[k] = srcU[j];
                            desV[k] = srcV[j];
                        }
                        desU += width;
                        srcU += (logo->width >> 1);
                        desV += width;
                        srcV += (logo->width >> 1);
                    }
                }
            }
        }
    }
    void convertI420(uint8_t* mainY, uint8_t* mainU, uint8_t* mainV, int width, int height) {
        int imageSize = width * height;
        for (auto it = m_auxes.begin(); it != m_auxes.end(); it++) {
            int auxFourCC = it->first;
            uint8_t* aux = it->second;
            if (auxFourCC == MAKE_FOURCC('I', '4', '2', '0')) {
                memcpy(aux, mainY, imageSize);
                memcpy(aux + imageSize, mainU, imageSize >> 2);
                memcpy(aux + imageSize + (imageSize >> 2), mainV, imageSize >> 2);
            } else if (auxFourCC == MAKE_FOURCC('Y', 'V', '1', '2')) {
                memcpy(aux, mainY, imageSize);
                memcpy(aux + imageSize, mainV, imageSize >> 2);
                memcpy(aux + imageSize + (imageSize >> 2), mainU, imageSize >> 2);
            } else if (auxFourCC == MAKE_FOURCC('N', 'V', '1', '2')) {
                libyuv::I420ToNV12(	mainY, width, mainU, width >> 1, mainV, width >> 1, aux, width, aux + imageSize, width, width, height);
            } else if (auxFourCC == MAKE_FOURCC('N', 'V', '2', '1')) {
                libyuv::I420ToNV21(	mainY, width, mainU, width >> 1, mainV, width >> 1, aux, width, aux + imageSize, width, width, height);
            } else if (auxFourCC != 0) {
                wli("unknown format:%c%c%c%c", (auxFourCC >> 24) & 0xff, (auxFourCC >> 16) & 0xff, (auxFourCC >> 8) & 0xff, (auxFourCC >> 0) & 0xff);
            }
        }
    }
    void convertNV12(uint8_t* mainY, uint8_t* mainUV, int width, int height) {
        int imageSize = width * height;
        for (auto it = m_auxes.begin(); it != m_auxes.end(); it++) {
            int auxFourCC = it->first;
            uint8_t* aux = it->second;
            if (auxFourCC == MAKE_FOURCC('I', '4', '2', '0')) {
                libyuv::NV12ToI420(mainY, width, mainUV, width, aux, width, aux + imageSize, width >> 1, aux + imageSize + (imageSize >> 2), width >> 1, width, height);
            } else if (auxFourCC == MAKE_FOURCC('Y', 'V', '1', '2')) {
                libyuv::NV12ToI420(mainY, width, mainUV, width, aux, width, aux + imageSize + (imageSize >> 2), width >> 1, aux + imageSize, width >> 1, width, height);
            } else if (auxFourCC == MAKE_FOURCC('N', 'V', '1', '2')) {
                memcpy(aux, mainY, imageSize);
                memcpy(aux + imageSize, mainUV, imageSize >> 1);
            } else if (auxFourCC == MAKE_FOURCC('N', 'V', '2', '1')) {
                memcpy(aux, mainY, imageSize);
                uint8_t* src = mainUV;
                uint8_t* des = aux + imageSize;
                uint8_t* end = src + (imageSize >> 1);
                while (src != end) {
                    *des++ = *(src + 1);
                    *des++ = *src;
                    src+= 2;
                }
            } else if (auxFourCC != 0) {
                wli("unknown format:%c%c%c%c", (auxFourCC >> 24) & 0xff, (auxFourCC >> 16) & 0xff, (auxFourCC >> 8) & 0xff, (auxFourCC >> 0) & 0xff);
            }
        }
    }
    void convertNV21(uint8_t* mainY, uint8_t* mainUV, int width, int height) {
        int imageSize = width * height;
        for (auto it = m_auxes.begin(); it != m_auxes.end(); it++) {
            int auxFourCC = it->first;
            uint8_t* aux = it->second;
            if (auxFourCC == MAKE_FOURCC('I', '4', '2', '0')) {
                libyuv::NV21ToI420(mainY, width, mainUV, width, aux, width, aux + imageSize, width >> 1, aux + imageSize + (imageSize >> 2), width >> 1, width, height);
            } else if (auxFourCC == MAKE_FOURCC('Y', 'V', '1', '2')) {
                libyuv::NV21ToI420(mainY, width, mainUV, width, aux, width, aux + imageSize + (imageSize >> 2), width >> 1, aux + imageSize, width >> 1, width, height);
            } else if (auxFourCC == MAKE_FOURCC('N', 'V', '1', '2')) {
                memcpy(aux, mainY, imageSize);
                uint8_t* src = mainUV;
                uint8_t* des = aux + imageSize;
                uint8_t* end = src + (imageSize >> 1);
                while (src != end) {
                    *des++ = *(src + 1);
                    *des++ = *src;
                    src+= 2;
                }
            } else if (auxFourCC == MAKE_FOURCC('N', 'V', '2', '1')) {
                memcpy(aux, mainY, imageSize);
                memcpy(aux + imageSize, mainUV, imageSize >> 1);
            } else if (auxFourCC != 0) {
                wli("unknown format:%c%c%c%c", (auxFourCC >> 24) & 0xff, (auxFourCC >> 16) & 0xff, (auxFourCC >> 8) & 0xff, (auxFourCC >> 0) & 0xff);
            }
        }
    }
    void render(uint8_t* main, int width, int height) {
        std::lock_guard<std::mutex> lock(m_mutex);
        int imageSize = width * height;
        int bufSize = imageSize * 3 / 2;
        if (m_mainFourCC == MAKE_FOURCC('I', '4', '2', '0')) {
            overlayI420(main, main + imageSize, main + imageSize + (imageSize >> 2), width, height);
            convertI420(main, main + imageSize, main + imageSize + (imageSize >> 2), width, height);
        } else if (m_mainFourCC == MAKE_FOURCC('Y', 'V', '1', '2')) {
            overlayI420(main, main + imageSize + (imageSize >> 2), main + imageSize, width, height);
            convertI420(main, main + imageSize + (imageSize >> 2), main + imageSize, width, height);
        } else if (m_mainFourCC == MAKE_FOURCC('N', 'V', '1', '2')) {
            overlayNV12(main, main + imageSize, width, height, false);
            convertNV12(main, main + imageSize, width, height);
        } else if (m_mainFourCC == MAKE_FOURCC('N', 'V', '2', '1')) {
            overlayNV12(main, main + imageSize, width, height, true);
            convertNV21(main, main + imageSize, width, height);
        } else {
            return wle("Unsupported format: %c%c%c%c", (m_mainFourCC >> 24) & 0xff, (m_mainFourCC >> 16) & 0xff, (m_mainFourCC >> 8) & 0xff, (m_mainFourCC >> 0) & 0xff);
        }
    }
};

extern "C" {

	JNIEXPORT jlong JNICALL Java_com_dylan_live_overlay_NativeMethod_native_1init(JNIEnv* env, jobject thiz,
                    jint mode, jint fourcc) {
		COverlay* overlay = new COverlay(mode, fourcc);
		return (long)overlay;
	}
    JNIEXPORT void JNICALL Java_com_dylan_live_overlay_NativeMethod_native_1set_1overlay(JNIEnv* env, jclass thiz,
                    jlong handle, jint index, jintArray jlogo, jint width, jint height, jint x, jint y, jint flags) {
        COverlay* overlay = (COverlay*)handle;
        if (overlay != nullptr) {
            uint8_t* logo = jlogo == nullptr ? nullptr : (uint8_t*)env->GetIntArrayElements(jlogo, JNI_FALSE);
            overlay->setLogo(index, logo, width, height, x, y, flags);
        }
    }
    JNIEXPORT void JNICALL Java_com_dylan_live_overlay_NativeMethod_native_1set_1aux(JNIEnv* env, jclass thiz,
                    jlong handle, jint fourcc, jobject jbuffer) {
        COverlay* overlay = (COverlay*)handle;
        if (overlay != nullptr) {
            uint8_t* aux = jbuffer == nullptr ? nullptr : (uint8_t*)env->GetDirectBufferAddress(jbuffer);
            overlay->setAux(fourcc, aux);
        }
    }
    JNIEXPORT void JNICALL Java_com_dylan_live_overlay_NativeMethod_native_1render(JNIEnv* env, jclass thiz,
                    jlong handle, jobject jmain, jint width, jint height) {
        COverlay* overlay = (COverlay*)handle;
        if (overlay != nullptr) {
            uint8_t* main = jmain == nullptr ? nullptr : (uint8_t*)env->GetDirectBufferAddress(jmain);
            overlay->render(main, width, height);
        }
    }
	JNIEXPORT void JNICALL Java_com_dylan_live_overlay_NativeMethod_native_1cleanup(JNIEnv* env, jobject thiz, jlong handle) {
		COverlay* overlay = (COverlay*)handle;
		if (overlay != NULL) {
			delete overlay;
		}
	}
}
